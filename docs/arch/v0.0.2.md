# Notes

This is what we are supposed to implement.

> [!WARNING]
> This file is historical and partially outdated.
> For current behavior and module layout, see `docs/arch/v0.0.4.md`.
>
> Notable drift from this doc:
> - IVF training is explicit (`Engine::train`) and not auto-triggered in `add`.
> - IVF search does not fall back pre-train; it throws until trained.
> - Source tree has been modularized into `core/indexes/math/storage/io`.

## Core Architecture (as implemented)

```mermaid
classDiagram
    direction LR

    class Engine {
        -unique_ptr~Index~ index_
        +Engine(spec)
        +add(vectors)
        +add(ids, vectors)
        +search(query, params)
        +search_batch(queries, params)
        +size()
        +dim()
    }

    class Index {
        <<interface>>
        +add(ids, vectors)*
        +search(query, params)*
        +size()*
        +dim()*
    }

    class SearchParams {
        +int k
        +int nprobe
    }

    class IndexSpec {
        +int dim
        +Metric metric
        +bool normalize
        +IndexKind kind
        +int nlist
    }

    class FlatIndex {
        -IndexSpec spec_
        -vector~float~ vectors_
        -vector~int64~ ids_
        +add(ids, vectors)
        +search(query, params)
    }

    class IVFIndex {
        -IndexSpec spec_
        -vector~float~ centroids_
        -vector~vector~float~~ cluster_vectors_
        -vector~vector~int64~~ cluster_ids_
        -vector~float~ untrained_vectors_
        -vector~int64~ untrained_ids_
        -bool is_trained_
        -long long total_vectors_
        +add(ids, vectors)
        +search(query, params)
    }

    class KMeans {
        +fit(vectors) vector~float~
        +predict(vectors, centroids) vector~int~
    }

    class TopK {
        -int k_
        -priority_queue heap_
        +push(id, score)
        +sorted_results()
    }

    namespace Kernels {
        class Math {
            +dot(a,b,d)
            +l2_squared(a,b,d)
            +normalize(v,d)
        }
    }

    Engine *-- Index : owns
    Engine ..> IndexSpec : configured by
    Engine ..> SearchParams : accepts

    Index <|-- FlatIndex
    Index <|-- IVFIndex

    IVFIndex ..> KMeans : uses for training

    FlatIndex ..> TopK : ranks hits
    IVFIndex ..> TopK : ranks hits

    FlatIndex ..> Math : scoring
    IVFIndex ..> Math : scoring/assignment
```

## Implementation details (current)

- **Training trigger:** `IVFIndex::train()` runs during `add(...)` when the index is not yet trained and enough vectors are available (`n >= nlist`). Until then, vectors/ids are buffered in `untrained_vectors_` / `untrained_ids_`.
- **Training algorithm:** Uses `clustering::KMeans` with k-means++ style initialization and a fixed RNG seed (42). Centroids are computed from buffered vectors, then each buffered vector is assigned to its nearest centroid to populate `cluster_vectors_` and `cluster_ids_`.
- **Post-train ingestion:** Once trained, new vectors are assigned to their nearest centroid via a brute-force centroid scan and appended to that clusterâ€™s storage.
- **Search behavior:**
  - If **not trained**, `search(...)` falls back to a flat scan over the untrained buffer.
  - If **trained**, the query is normalized (cosine only), distances to all centroids are computed, and the closest `nprobe` clusters are scanned.
  - Scores are **dot product** for cosine and **negative L2 squared** for L2.
- **Normalization:** When `normalize=true` and `metric=Cosine`, both vectors (at add time) and queries (at search time) are L2-normalized.
## Search Logic (as implemented)

```mermaid
sequenceDiagram
    participant U as User
    participant E as Engine
    participant IVF as IVFIndex
    participant K as Kernels
    participant T as TopK

    U->>E: search(query, params{k, nprobe})
    E->>IVF: search(query, params)

    Note over IVF: Stage 0 (optional): normalize query if cosine
    IVF->>IVF: maybe_normalize(query)

    Note over IVF: Stage 1: compute centroid distances
    IVF->>IVF: compute L2 distance to each centroid
    IVF->>IVF: partial_sort by distance (top nprobe)

    Note over IVF: Stage 2: scan selected lists
    IVF->>T: init TopK(k)

    loop for each selected centroid
        IVF->>IVF: cluster = cluster_vectors_[cid]
        loop for each vector in cluster
            IVF->>K: compute_score(query, vec)
            K-->>IVF: score
            IVF->>T: push(id, score)
        end
    end

    T-->>IVF: sorted_results()
    IVF-->>E: hits (score desc)
    E-->>U: hits
```
